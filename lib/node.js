// Generated by CoffeeScript 2.0.0-beta2
(function() {
  var AstNode, BINARY_LOGICAL_OPS, BINARY_RELATION_OPS, BinaryLogicalOp, BinaryRelationOp, Field, Leaf, NODE_TYPE, SemanticError, UNARY_LOGICAL_OPS, UNARY_RELATION_OPS, UnaryLogicalOp, UnaryRelationOp, lo,
    indexOf = [].indexOf;

  lo = require('lodash');

  NODE_TYPE = require("./type");

  ({UNARY_LOGICAL_OPS, UNARY_RELATION_OPS, BINARY_LOGICAL_OPS, BINARY_RELATION_OPS} = require("./op"));

  AstNode = class AstNode {
    constructor(name, token, parent, related_field_name) {
      this.token = token;
      this.name = name;
      this.parent = parent;
      this.children = [];
      this.related_field_name = related_field_name;
    }

    parse() {
      var N, name, ref, token;
      if (this.is_leaf(this.token)) {
        this.next(Leaf, null, this.token);
      } else if (lo.isEmpty(this.token)) {
        throw SyntaxError(`the ${this.type} missing child node`);
      } else {
        ref = this.token;
        for (name in ref) {
          token = ref[name];
          N = this.detect_node_type(name, token);
          this.next(N, name, token);
        }
      }
      return this;
    }

    next(Node, name, token) {
      this.syntax_check(Node);
      this.semantic_check(Node);
      return this.children.push(new Node(name, token != null ? token : null, this, this.related_field_name).parse());
    }

    semantic_check(Node) {}

    syntax_check(Node) {
      var ref;
      if (ref = Node.prototype.type, indexOf.call(this.child_type, ref) < 0) {
        throw new SemanticError(`invalid type: \`${Node.prototype.type}\`, the accepted child type of \`${this.type}\` must be included in ${this.child_type}`);
      }
    }

    detect_node_type(name, token) {
      switch (false) {
        case !this.is_urop(name):
          return UnaryRelationOp;
        case !this.is_brop(name):
          return BinaryRelationOp;
        case !this.is_ulop(name):
          return UnaryLogicalOp;
        case !this.is_blop(name):
          return BinaryLogicalOp;
        case !this.is_op(name):
          throw new SyntaxError(`the operator \`${name}\` doesn't implement in the current FFI`);
        default:
          return Field;
      }
    }

    is_leaf(token) {
      return lo.isString(token) || lo.isNumber(token) || lo.isBoolean(token) || (token == null);
    }

    is_urop(name) {
      return indexOf.call(UNARY_RELATION_OPS, name) >= 0;
    }

    is_ulop(name) {
      return indexOf.call(UNARY_LOGICAL_OPS, name) >= 0;
    }

    is_brop(name) {
      return indexOf.call(BINARY_RELATION_OPS, name) >= 0;
    }

    is_blop(name) {
      return indexOf.call(BINARY_LOGICAL_OPS, name) >= 0;
    }

    is_op(name) {
      return name.startsWith("$");
    }

  };

  Field = (function() {
    class Field extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        if (this.is_leaf(token)) {
          this.token = {
            $eq: token
          };
        }
        this.value = name;
        this.related_field_name = name;
      }

      semantic_check(Node) {
        super.semantic_check(Node);
        if (this.parent.related_field_name != null) {
          throw new SemanticError(`previous field name [${this.parent.related_field_name}] has been found, can not specify other \`Field\` type inside one \`Field\``);
        } else if (this.children.length > 0) {
          throw new SemanticError("`Field` type can not have multiple child");
        }
      }

      gen(ffi) {
        var child;
        [child] = this.children;
        return child.gen(ffi);
      }

    };

    Field.prototype.type = NODE_TYPE.FIELD;

    Field.prototype.child_type = [NODE_TYPE.LEAF, NODE_TYPE.UNARY_LOGICAL_OPERATOR, NODE_TYPE.BINARY_LOGICAL_OPERATOR, NODE_TYPE.BINARY_RELATION_OPERATOR];

    return Field;

  })();

  UnaryLogicalOp = (function() {
    class UnaryLogicalOp extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        this.value = name.slice(1);
      }

      semantic_check(Node) {
        super.semantic_check(Node);
        if (this.children.length > 0) {
          throw new SemanticError(`unary logical operator [${this.name}] can't have more than one child`);
        }
      }

      gen(ffi) {
        var child;
        [child] = this.children;
        return ffi[this.value](child.gen(ffi));
      }

    };

    UnaryLogicalOp.prototype.type = NODE_TYPE.UNARY_LOGICAL_OPERATOR;

    UnaryLogicalOp.prototype.child_type = [NODE_TYPE.FIELD, NODE_TYPE.UNARY_LOGICAL_OPERATOR, NODE_TYPE.BINARY_LOGICAL_OPERATOR, NODE_TYPE.UNARY_RELATION_OPERATOR, NODE_TYPE.BINARY_RELATION_OPERATOR, NODE_TYPE.LEAF];

    return UnaryLogicalOp;

  })();

  BinaryLogicalOp = (function() {
    class BinaryLogicalOp extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        this.value = name.slice(1);
      }

      gen(ffi) {
        var child;
        return ffi[this.value](...(function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            results.push(child.gen(ffi));
          }
          return results;
        }).call(this));
      }

    };

    BinaryLogicalOp.prototype.type = NODE_TYPE.BINARY_LOGICAL_OPERATOR;

    BinaryLogicalOp.prototype.child_type = [NODE_TYPE.FIELD, NODE_TYPE.UNARY_LOGICAL_OPERATOR, NODE_TYPE.BINARY_LOGICAL_OPERATOR, NODE_TYPE.UNARY_RELATION_OPERATOR, NODE_TYPE.BINARY_RELATION_OPERATOR];

    return BinaryLogicalOp;

  })();

  UnaryRelationOp = (function() {
    class UnaryRelationOp extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        this.value = name.slice(1);
      }

      semantic_check(Node) {
        super.semantic_check(Node);
        if (this.parent.related_field_name != null) {
          throw new SemanticError(`unary relation operator [${this.name}] can't be used under a Field, but previous related field: ${this.parent.related_field_name}`);
        }
        if (this.children.length > 0) {
          throw new SemanticError(`unary relation operator [${this.name}] can't have more than one child`);
        }
      }

      gen(ffi) {
        var leaf;
        [leaf] = this.children;
        return ffi[this.value](leaf.gen());
      }

    };

    UnaryRelationOp.prototype.type = NODE_TYPE.UNARY_RELATION_OPERATOR;

    UnaryRelationOp.prototype.child_type = [NODE_TYPE.LEAF];

    return UnaryRelationOp;

  })();

  BinaryRelationOp = (function() {
    class BinaryRelationOp extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        this.value = name.slice(1);
      }

      gen(ffi) {
        var leaf;
        [leaf] = this.children;
        return ffi[this.value](this.related_field_name, leaf.gen());
      }

    };

    BinaryRelationOp.prototype.type = NODE_TYPE.BINARY_RELATION_OPERATOR;

    BinaryRelationOp.prototype.child_type = [NODE_TYPE.LEAF];

    return BinaryRelationOp;

  })();

  Leaf = (function() {
    class Leaf extends AstNode {
      constructor(name, token, parent, related_field_name) {
        super(name, token, parent, related_field_name);
        this.value = token;
        this.children = null;
      }

      parse() {
        return this;
      }

      gen() {
        return this.value;
      }

    };

    Leaf.prototype.type = NODE_TYPE.LEAF;

    return Leaf;

  })();

  SemanticError = class SemanticError extends Error {
    constructor(message) {
      super();
      this.message = message;
      this.name = 'SemanticError';
    }

  };

  module.exports = {AstNode, Leaf, Field, UnaryLogicalOp, UnaryRelationOp, BinaryLogicalOp, BinaryRelationOp};

}).call(this);
